# GitHub Copilot Web Application Architecture Instructions

**Instruction Version**: 1.3.3
**Last Updated**: 2025-09-06 @ 22:12
**Target AI**: GitHub Copilot

## Integration Reference

This instruction file is part of a comprehensive AI agent integration system. For universal guidelines and integration with other AI agents, see:

- **Universal Guidelines**: `AI_AGENT_INTEGRATION_GUIDE.md`
- **Claude Instructions**: `claude/claude-architecture-instructions.md` (unified, comprehensive guide)
- **Cross-Agent Compatibility**: Follow the universal framework for consistent guidance across all AI tools

## Enhanced Claude Integration

**New in v1.3.3**: This repository includes an AI-Powered Code Review workflow system that complements GitHub Copilot's code generation capabilities with comprehensive automated analysis and complete architecture documentation.

### AI Tool Collaboration Strategy

When working with repositories that have the AI-Powered Code Review system:

1. **Code Generation** (GitHub Copilot): Generate clean, maintainable code following architectural patterns
2. **Code Review** (Enhanced Claude): Automated analysis through `/architecture-review`, `/security-scan`, `/performance-check` commands
3. **Optimization** (Both): Iterative improvement based on automated feedback and suggestions

### Integration Benefits

- **Consistent Quality**: Copilot suggestions validated against established architecture principles
- **Security Validation**: Generated code automatically scanned for security vulnerabilities
- **Performance Optimization**: Real-time analysis of performance implications
- **Documentation Quality**: Automated validation of code comments and documentation

### Workflow Integration

```typescript
// GitHub Copilot generates code following patterns like this:
// Claude Enhanced workflow validates against security, performance, and architecture standards

// Example: Copilot suggests secure API pattern
const ApiClient = {
  async request<T>(endpoint: string, options: RequestOptions): Promise<T> {
    // Security-first pattern generated by Copilot
    // Validated by Enhanced Claude /security-scan
    const token = await getSecureToken();
    
    return fetch(endpoint, {
      ...options,
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
        ...options.headers,
      },
    }).then(handleResponse);
  }
};
```text

For complete AI-Powered Code Review workflow setup, see the repository's IMPLEMENTATION_GUIDE.md.

## Code Generation Philosophy

When generating code suggestions for web applications, prioritize clean, maintainable, and secure patterns. Always suggest industry best practices and include relevant comments explaining architectural decisions.

## Architecture Pattern Recognition

### Identify Project Context

Analyze the existing codebase to understand:

- **Framework**: React, Vue, Angular, Express, Django, etc.
- **Language**: TypeScript, JavaScript, Python, C#, Java
- **Patterns**: Clean Architecture, MVC, MVP, Component-based
- **Testing Framework**: Jest, Cypress, pytest, xUnit
- **Build Tools**: Webpack, Vite, Rollup, Parcel

### Suggest Appropriate Patterns

Based on project context, recommend:

**For Component-Based Frontend:**

```typescript
// Suggest functional components with hooks
const UserProfile: React.FC<UserProfileProps> = ({ userId }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Custom hook for data fetching
  const { data, isLoading, error: fetchError } = useUser(userId);

  // Error boundary and loading states
  if (isLoading) return <LoadingSpinner />;
  if (fetchError) return <ErrorMessage error={fetchError} />;

  return (
    <div className="user-profile" role="main" aria-label="User Profile">
      {/* Accessible, semantic HTML */}
    </div>
  );
};
```text

**For Backend API Design:**

```typescript
// Suggest clean controller patterns
@Controller('/api/users')
export class UserController {
  constructor(
    private readonly userService: UserService,
    private readonly validator: ValidationService
  ) {}

  @Get('/:id')
  @UseGuards(AuthGuard)
  async getUser(
    @Param('id', ParseUUIDPipe) id: string,
    @CurrentUser() currentUser: User
  ): Promise<UserDto> {
    // Input validation
    await this.validator.validateUserAccess(currentUser, id);
    
    // Business logic delegation
    const user = await this.userService.findById(id);
    
    // Response transformation
    return this.userService.toDto(user);
  }
}
```text

## Security-First Code Suggestions

### Authentication & Authorization

```typescript
// Suggest secure authentication patterns
class AuthService {
  async login(credentials: LoginDto): Promise<AuthResult> {
    // Input validation
    const validatedInput = await this.validator.validate(credentials);
    
    // Rate limiting check
    await this.rateLimiter.checkAttempts(validatedInput.email);
    
    // Secure password verification
    const user = await this.userRepository.findByEmail(validatedInput.email);
    const isValid = await bcrypt.compare(validatedInput.password, user.hashedPassword);
    
    if (!isValid) {
      await this.rateLimiter.recordFailedAttempt(validatedInput.email);
      throw new UnauthorizedException('Invalid credentials');
    }
    
    // JWT with secure claims
    const payload = { sub: user.id, email: user.email, roles: user.roles };
    const accessToken = this.jwtService.sign(payload, { expiresIn: '15m' });
    const refreshToken = this.jwtService.sign(payload, { expiresIn: '7d' });
    
    return { accessToken, refreshToken, user: this.userService.toSafeDto(user) };
  }
}
```text

### Input Validation & Sanitization

```typescript
// Suggest validation decorators and DTOs
export class CreateUserDto {
  @IsEmail()
  @IsNotEmpty()
  @Transform(({ value }) => value.toLowerCase().trim())
  email: string;

  @IsString()
  @MinLength(8)
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
  password: string;

  @IsString()
  @IsNotEmpty()
  @Sanitize()
  firstName: string;

  @IsString()
  @IsNotEmpty()
  @Sanitize()
  lastName: string;
}
```text

## Performance-Optimized Patterns

### Database Optimization

```typescript
// Suggest efficient database patterns
@Entity()
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  @Index() // Suggest appropriate indexing
  email: string;

  @OneToMany(() => Post, post => post.author, { lazy: true })
  posts: Promise<Post[]>;

  // Suggest projection methods for performance
  static findWithPostCount(): SelectQueryBuilder<User> {
    return this.createQueryBuilder('user')
      .leftJoin('user.posts', 'post')
      .select(['user.id', 'user.email', 'user.firstName'])
      .addSelect('COUNT(post.id)', 'postCount')
      .groupBy('user.id');
  }
}
```text

### Frontend Performance

```typescript
// Suggest memoization and optimization
const ExpensiveComponent: React.FC<Props> = memo(({ data, onUpdate }) => {
  // Suggest useMemo for expensive calculations
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      computed: expensiveCalculation(item)
    }));
  }, [data]);

  // Suggest useCallback for event handlers
  const handleItemClick = useCallback((id: string) => {
    onUpdate(id);
  }, [onUpdate]);

  // Suggest virtualization for large lists
  return (
    <VirtualizedList
      items={processedData}
      itemHeight={50}
      onItemClick={handleItemClick}
    />
  );
});
```text

## Testing Patterns

### Unit Testing

```typescript
// Suggest comprehensive test patterns
describe('UserService', () => {
  let service: UserService;
  let mockRepository: jest.Mocked<UserRepository>;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        UserService,
        { provide: UserRepository, useValue: createMockRepository() }
      ]
    }).compile();

    service = module.get<UserService>(UserService);
    mockRepository = module.get(UserRepository);
  });

  describe('createUser', () => {
    it('should create user with valid data', async () => {
      // Arrange
      const userData = { email: 'test@example.com', password: 'SecurePass123!' };
      const expectedUser = { id: '123', ...userData };
      mockRepository.save.mockResolvedValue(expectedUser);

      // Act
      const result = await service.createUser(userData);

      // Assert
      expect(result).toEqual(expectedUser);
      expect(mockRepository.save).toHaveBeenCalledWith(
        expect.objectContaining({
          email: userData.email,
          hashedPassword: expect.any(String)
        })
      );
    });

    it('should throw error for duplicate email', async () => {
      // Arrange
      mockRepository.save.mockRejectedValue(new ConflictException());

      // Act & Assert
      await expect(service.createUser({ email: 'test@example.com' }))
        .rejects.toThrow(ConflictException);
    });
  });
});
```text

### Integration Testing

```typescript
// Suggest API integration test patterns
describe('UserController (e2e)', () => {
  let app: INestApplication;
  let userRepository: Repository<User>;

  beforeEach(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    userRepository = moduleFixture.get('UserRepository');
    await app.init();
  });

  it('/users (POST) should create user', () => {
    const userData = {
      email: 'test@example.com',
      password: 'SecurePass123!',
      firstName: 'John',
      lastName: 'Doe'
    };

    return request(app.getHttpServer())
      .post('/users')
      .send(userData)
      .expect(201)
      .expect(res => {
        expect(res.body).toHaveProperty('id');
        expect(res.body.email).toBe(userData.email);
        expect(res.body).not.toHaveProperty('password');
      });
  });
});
```text

## Error Handling & Logging

### Structured Error Handling

```typescript
// Suggest consistent error handling patterns
export class ApiError extends Error {
  constructor(
    public readonly statusCode: number,
    public readonly message: string,
    public readonly code: string,
    public readonly details?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger(GlobalExceptionFilter.name);

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    let status = 500;
    let message = 'Internal server error';
    let code = 'INTERNAL_ERROR';

    if (exception instanceof ApiError) {
      status = exception.statusCode;
      message = exception.message;
      code = exception.code;
    }

    // Structured logging
    this.logger.error('Exception occurred', {
      exception: exception instanceof Error ? exception.message : exception,
      stack: exception instanceof Error ? exception.stack : undefined,
      request: {
        method: request.method,
        url: request.url,
        headers: request.headers,
        body: request.body
      },
      response: { status, code }
    });

    response.status(status).json({
      statusCode: status,
      message,
      code,
      timestamp: new Date().toISOString(),
      path: request.url
    });
  }
}
```text

## Code Comments & Documentation

### Suggest Meaningful Comments

```typescript
/**
 * Processes user payment with retry logic and fraud detection
 * 
 * @param paymentData - Payment information including amount and method
 * @param userId - Unique identifier for the user making payment
 * @returns Promise resolving to payment result with transaction ID
 * @throws PaymentError when payment processing fails
 * @throws FraudDetectedError when suspicious activity is detected
 */
async processPayment(
  paymentData: PaymentRequest,
  userId: string
): Promise<PaymentResult> {
  // Validate payment amount and method
  await this.validatePaymentData(paymentData);
  
  // Check for fraudulent activity patterns
  const fraudScore = await this.fraudService.analyzePayment(paymentData, userId);
  if (fraudScore > FRAUD_THRESHOLD) {
    throw new FraudDetectedError('Suspicious payment pattern detected');
  }
  
  // Process payment with exponential backoff retry
  return await this.retryService.execute(
    () => this.paymentGateway.processPayment(paymentData),
    { maxAttempts: 3, backoffMs: 1000 }
  );
}
```text

## Configuration & Environment Management

### Suggest Environment-Based Configuration

```typescript
// Suggest type-safe configuration patterns
export interface AppConfig {
  port: number;
  database: {
    host: string;
    port: number;
    username: string;
    password: string;
    database: string;
  };
  jwt: {
    secret: string;
    expiresIn: string;
  };
  redis: {
    host: string;
    port: number;
  };
}

export const config = (): AppConfig => ({
  port: parseInt(process.env.PORT || '3000', 10),
  database: {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '5432', 10),
    username: process.env.DB_USERNAME || 'postgres',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_DATABASE || 'app'
  },
  jwt: {
    secret: process.env.JWT_SECRET || (() => {
      throw new Error('JWT_SECRET environment variable is required');
    })(),
    expiresIn: process.env.JWT_EXPIRES_IN || '1h'
  },
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379', 10)
  }
});
```text

## Code Quality Guidelines

### Suggest Code Organization

- Use consistent file and folder naming conventions
- Implement barrel exports for clean imports
- Separate concerns with clear module boundaries
- Use TypeScript strict mode and proper type definitions
- Implement proper dependency injection patterns
- Follow SOLID principles in class design

### Suggest Performance Best Practices

- Implement proper caching strategies
- Use database connection pooling
- Implement rate limiting for API endpoints
- Use compression for API responses
- Implement proper asset optimization
- Use CDN for static assets

### Suggest Security Best Practices

- Never expose sensitive data in client-side code
- Implement proper CORS configuration
- Use parameterized queries to prevent SQL injection
- Implement proper session management
- Use HTTPS in production
- Implement security headers (CSP, HSTS, etc.)

Remember: Always consider the specific context of the project and suggest patterns that align with the existing codebase architecture and team conventions.

## Standard AI Agent Requirements

**These requirements apply to ALL AI agents working with this repository:**

### Documentation Update Requirements

Every change you make MUST include:

1. **System File Updates**: Update all relevant system files (README.md, configuration files, validation scripts)
2. **Cross-Reference Updates**: Ensure all documentation references remain accurate after changes
3. **Template Updates**: Update templates if changes affect their usage or structure
4. **Integration Updates**: Update AI agent integration guides and instruction files
5. **Validation**: Run repository validation to ensure all documentation passes compliance checks

### Version Bump Evaluation Requirements

For every change, evaluate if a version bump is required:

1. **Major Version (X.0.0)**: Breaking changes, major architectural shifts, or fundamental API changes
2. **Minor Version (0.X.0)**: New features, significant enhancements, or new AI agent integrations
3. **Patch Version (0.0.X)**: Bug fixes, documentation improvements, or minor optimizations

**Process**:

- Use `npm run versions:validate` to check current version consistency
- Use `npm run versions:bump-major|minor|patch` to update versions
- Update CHANGELOG.md with detailed change descriptions
- Ensure all 100+ files maintain version consistency

### Quality Standards

- **Zero Breaking Changes**: Maintain backward compatibility unless major version bump
- **Comprehensive Testing**: Validate all changes with existing validation scripts
- **Documentation Currency**: Keep all documentation up-to-date and accurate
- **Repository Compliance**: Ensure all changes pass repository validation checks

These requirements ensure consistency across all AI agents and maintain the repository's high quality standards.
